#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

const rootDir = path.resolve(__dirname, '..');
const perfDir = path.join(rootDir, 'evidence/performance');
const outputFile = path.join(rootDir, 'PERFORMANCE_DASHBOARD.md');

/**
 * Performance Dashboard Generator
 * Aggregates structured evidence to visualize ecosystem health trends.
 */

function generate() {
    if (!fs.existsSync(perfDir)) {
        console.log(chalk.yellow('[WARN] No performance evidence found. Run check_performance.cjs first.'));
        return;
    }

    const files = fs.readdirSync(perfDir).filter(f => f.endsWith('.json')).sort();
    if (files.length === 0) return;

    // Load and aggregate
    const reports = files.map(f => JSON.parse(fs.readFileSync(path.join(perfDir, f), 'utf8')));
    const latest = reports[reports.length - 1];

    let md = "# Performance & Efficiency Intelligence Dashboard\n\n";
    md += `**Last Scan**: ${latest.timestamp}\n`;
    md += `**Total Records**: ${latest.summary.total_records}\n`;
    md += `**Unique Skills**: ${latest.summary.unique_skills}\n\n`;

    md += "## 1. Top Performance Alerts\n\n";
    if (latest.regressions.length > 0) {
        md += "### âš ï¸ Regressions (Significant Slowdown)\n\n";
        md += "| Skill | Current | Historical Avg | Factor |\n";
        md += "| :--- | :--- | :--- | :--- |\n";
        latest.regressions.forEach(r => {
            md += `| **${r.skill}** | ${r.lastDuration}ms | ${r.historicalAvg}ms | ${r.increaseRate}x |\n`;
        });
        md += "\n";
    }

    if (latest.efficiency_alerts.length > 0) {
        md += "### ğŸ’ Low Efficiency (Resource vs Speed)\n\n";
        md += "| Skill | Score | Trend | Latency | Memory |\n";
        md += "| :--- | :--- | :--- | :--- | :--- |\n";
        latest.efficiency_alerts.sort((a, b) => a.efficiencyScore - b.efficiencyScore).forEach(s => {
            let trendIcon = 'â–';
            if (s.trend === 'improving') trendIcon = 'ğŸ“ˆ';
            if (s.trend === 'degrading') trendIcon = 'ğŸ“‰';
            
            md += `| **${s.skill}** | ${s.efficiencyScore} | ${trendIcon} | ${s.avgMs}ms | ${s.peakHeapMB}MB |\n`;
        });
        md += "\n";
    }

    md += "## 2. Stability Watchlist (High Error Rates)\n\n";
    md += "| Skill | Error Rate | Fail/Total |\n";
    md += "| :--- | :--- | :--- |\n";
    latest.unstable_skills.sort((a, b) => b.errorRate - a.errorRate).forEach(s => {
        md += `| **${s.skill}** | ${s.errorRate}% | ${s.errors}/${s.executions} |\n`;
    });

    md += "\n## 3. Bottleneck Analysis (Slowest Skills)\n\n";
    md += "| Skill | Avg Time | Max Time |\n";
    md += "| :--- | :--- | :--- |\n";
    latest.slow_skills.forEach(s => {
        md += `| **${s.skill}** | ${s.avgMs}ms | ${s.maxMs}ms |\n`;
    });

    md += "\n## 4. Cache Efficiency (IO Optimization)\n\n";
    const cacheReadySkills = reports[reports.length - 1].unstable_skills.map(s => {
        // We reuse the stability list but need to filter/sort by cache if we had more specific data
        // For now, let's assume reportFromHistory result is available or simulate from latest
        return { skill: s.skill, ratio: s.cacheHitRatio || 0 };
    }).sort((a, b) => b.ratio - a.ratio).slice(0, 10);

    if (cacheReadySkills.length > 0) {
        md += "| Skill | Cache Hit Ratio | Status |\n";
        md += "| :--- | :--- | :--- |\n";
        cacheReadySkills.forEach(s => {
            const icon = s.ratio > 80 ? 'ğŸš€' : (s.ratio > 50 ? 'ğŸ“ˆ' : 'ğŸŒ');
            md += `| ${s.skill} | ${s.ratio}% | ${icon} |\n`;
        });
    }

    md += "\n## 5. Performance Trends\n\n";
    md += "*(Historical comparison logic to be expanded)*\n";
    md += `Total reports analyzed: ${reports.length}\n`;

    md += "\n---\n*Generated by Performance Engineer Tool*";

    fs.writeFileSync(outputFile, md);
    console.log(chalk.green(`[SUCCESS] Performance Dashboard generated at ${outputFile}`));
}

generate();
